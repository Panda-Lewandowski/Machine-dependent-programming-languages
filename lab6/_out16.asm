PUBLIC	PR_Out16
EXTRN	PR_NewLine:NEAR

Data	SEGMENT	PUBLIC
	simbols	DB	'0123456789ABCDEF'
Data	ENDS




Code	SEGMENT	PUBLIC
	ASSUME CS:Code, DS:Data
;--------------------------------------------------------------------------------------
;Печатает переменную, переданную через стек, как шестнадцатиричное число без знака (15 как F, -15 как FFF1)
;--------------------------------------------------------------------------------------
PR_Out16	PROC	NEAR
	PUSH	BP								;передаем параметр
	MOV		BP,SP
	PUSH	AX								;используем для деления
	PUSH	DX
	PUSH	BX

	MOV		AX,[BP+4]					;получаем в АХ число, которое надо распечатать
	MOV		BX,16							;делить будем на 16; BX целиком чтобы возникало
													;деление двойного слова (и не возникало переполнения)

	;а теперь, алгоритм следующий: предположим в АХ лежит шестнадцатеричное A1C, тогда вначале мы выделим место под это число,
	;то есть > ___ , а потом будем печатать со сдвигом влево: > __C , > _1C , > A1C

	PUSH	AX								;сохраним АХ, потому что нам его два раза печатать

;в этом цикле будем печатать необходимое количество пропусков
LO16_Div1:
		MOV		DX,0
		DIV		BX							;AX делим на BX(основание), остаток будем искать в DX
		PUSH	AX							;сохраним значение AX (целая часть)
		MOV		AH,2						;печатаем пропуск
		MOV		DL,'a'
		INT		21h
		POP		AX							;восстанавливаем число
		CMP		AX,0						;если оно не ноль
		JNE		LO16_Div1				;то прыг

		MOV	AH,2
		MOV DL,8							;делаем один откат назад
		INT 21h

		POP		AX							;восстанавливаем ИЗНАЧАЛЬНОЕ число

LO16_Div2:
		MOV		DX,0
		DIV		BX							;AX делим на BX(основание), остаток будем искать в DX
		PUSH	AX							;сохраним значение AX (целая часть)

		;CMP		DL,9						;сравниваем с 9
		;JA		LO16_AddA				;прыг если выше(больше?)(добавляем смещение по символу "А", а не по "0")
		;ADD		DL,'0'					;печатаем значение DX (остаток)

		PUSH	BX
		MOV   BX, OFFSET simbols
		MOV		AL, DL
		XLAT
		MOV		DL, AL
		POP 	BX
		MOV		AH,2
		JMP		LO16_Add0

LO16_AddA:
		ADD		DL,'A'
		SUB		DL,10

LO16_Add0:
		INT		21h							;определились с символом, теперь выводим
		MOV		DL,8						;смещаемся назад ДВАЖДЫ
		INT		21h
		INT		21h
		POP		AX							;восстанавливаем оставшуюся часть
		CMP		AX,0						;если число еще не ноль
		JNE		LO16_Div2				;то прыг


	POP		BX
	POP		DX
	POP		AX
	POP		BP
	RET

	RET
PR_Out16	ENDP
;--------------------------------------------------------------------------------------
Code	ENDS

END
